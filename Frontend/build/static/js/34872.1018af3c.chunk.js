/*! For license information please see 34872.1018af3c.chunk.js.LICENSE.txt */
"use strict";(self.webpackChunknorthwind=self.webpackChunknorthwind||[]).push([[34872],{34872:(t,e,o)=>{o.d(e,{A:()=>G,a:()=>O,b:()=>T,m:()=>W,p:()=>A,u:()=>x});var n=o(62153);var s=t=>t.constructor.elementProperties;var r,i=(r=63,t=>{const e=t.manager.internals.members;return Object.entries(null!==e&&void 0!==e?e:{}).filter((t=>{let[e,[o]]=t;return 0!==(o&r)})).map((t=>{let[e]=t;return e}))}),a=(t,e)=>{var o;return null===(o=t.manager.internals.members)||void 0===o||null===(o=o[e])||void 0===o?void 0:o[0]};function c(t,e){const o=a(t,e);return void 0===o?void 0:32&o?"state":"prop"}var l,h=Symbol("controller"),d=["The value you passed is not a controller and not a controller exports. If ","your controller exports a literal value, try making your controller export ","an object instead"].join(""),p=class t{constructor(e){this._callbacks={hostConnected:[],hostDisconnected:[],hostLoad:[],hostLoaded:[],hostUpdate:[],hostUpdated:[],hostDestroy:[],hostLifecycle:[]},this._ready=new n.D,this._lifecycleDisconnected=[],this.connectedCalled=!1,this.willLoadCalled=!1,this.didLoadCalled=!1,this[l]=!0,this.ready=this._ready.promise,this._exports=m(this),this._exportWatchers=new Set;const o=function(t){if("addController"in t)return t;throw new Error("Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line")}(null!==e&&void 0!==e?e:t.internals.retrieveComponent(new.target.name));Object.defineProperty(this,"component",{writable:!1,enumerable:!1,configurable:!0,value:o}),this.component.addController(this),t.internals.setParentController(this),"hostDestroy"in this&&this.component.manager.ensureHasDestroy();void 0===this.component.manager||queueMicrotask((()=>this.catchUpLifecycle()))}catchUpLifecycle(){const{manager:t}=this.component;!t.connectedCalled||this.connectedCalled||this.triggerConnected();!t.willLoadCalled||this.triggerLoad().then((()=>{!t.didLoadCalled||this.triggerLoaded()})).catch(console.error)}get exports(){return this._exports}set exports(t){this._exports!==t&&(this._exports=t,this.connectedCalled&&this.component.requestUpdate(),this._exportWatchers.forEach(n.d)),this._ready.resolve(t)}setProvisionalExports(t){this._exports=m(t),this._exportWatchers.forEach(n.d)}watchExports(t){const e=()=>t(this._exports);return this._exportWatchers.add(e),()=>{this._exportWatchers.delete(e)}}get use(){return t.internals.setAmbientComponent(this.component),t.internals.use}get useRef(){return t.internals.setAmbientComponent(this.component),t.internals.useRef}get useRefSync(){return t.internals.setAmbientComponent(this.component),t.internals.useRefSync}bypassSetter(e){t.internals.shouldBypassSetter=!0;try{return e()}finally{t.internals.shouldBypassSetter=!1}}bypassReadonly(e){t.internals.shouldBypassReadonly=!0;try{return e()}finally{t.internals.shouldBypassReadonly=!1}}bypassGetter(e){t.internals.shouldBypassGetter=!0;try{return e()}finally{t.internals.shouldBypassGetter=!1}}dynamicGetSet(t,e){this.genericGetSet(t,e)}genericGetSet(t,e){var o,n;const s=e,r=this.component.manager.internals;var i;"function"===typeof s.get&&(null!==(i=(o=r.getters)[t])&&void 0!==i||(o[t]=[]),r.getters[t].unshift(s.get));const a="ignore"===s.set?g:s.set;var c;a&&(null!==(c=(n=r.setters)[t])&&void 0!==c||(n[t]=[]),r.setters[t].unshift(a))}watch(t,e){var o,s;if(void 0===a(this.component,t))throw new Error('Trying to watch a non-@property, non-@state property "'.concat(t,'". Either convert it into a @state() or use get/set syntax'));const r=this.component.manager.internals;null!==(o=(s=r.allWatchers)[t])&&void 0!==o||(s[t]=[]);const i=r.allWatchers[t],c=e,l=(t,e,o)=>(0,n.d)(c,null,t,e,o);return i.push(l),()=>{const t=i.indexOf(l);-1!==t&&i.splice(t,1)}}controllerRemoved(){this.component.el.isConnected&&this.triggerDisconnected(),this.triggerDestroy()}onConnected(t){this._callbacks.hostConnected.push(t)}onDisconnected(t){this._callbacks.hostDisconnected.push(t)}onLoad(t){this._callbacks.hostLoad.push(t)}onLoaded(t){this._callbacks.hostLoaded.push(t)}onUpdate(t){this._callbacks.hostUpdate.push(t)}onUpdated(t){this._callbacks.hostUpdated.push(t)}onDestroy(t){this.component.manager.ensureHasDestroy(),this._callbacks.hostDestroy.push(t)}onLifecycle(t){this._callbacks.hostLifecycle.push(t),this.connectedCalled&&this.component.el.isConnected&&this._callLifecycle(t)}triggerConnected(){const t=this;t.hostConnected&&(0,n.d)(t.hostConnected,t),this._callbacks.hostConnected.forEach(n.d),this.triggerLifecycle(),this.connectedCalled=!0}triggerDisconnected(){const t=this;t.hostDisconnected&&(0,n.d)(t.hostDisconnected,t),this._callbacks.hostDisconnected.forEach(n.d),this._lifecycleDisconnected.forEach(n.d),this._lifecycleDisconnected=[]}async triggerLoad(){if(this.willLoadCalled)return;this.willLoadCalled=!0;const t=this;t.hostLoad&&await(0,n.e)(t.hostLoad,t),this._callbacks.hostLoad.length>0&&await Promise.allSettled(this._callbacks.hostLoad.map(n.e)),this._ready.resolve(this._exports)}triggerLoaded(){if(this.didLoadCalled)return;const t=this;t.hostLoaded&&(0,n.d)(t.hostLoaded,t),this._callbacks.hostLoaded.forEach(n.d),this.didLoadCalled=!0}triggerUpdate(){const t=this;t.hostUpdate&&(0,n.d)(t.hostUpdate,t),this._callbacks.hostUpdate.forEach(n.d)}triggerUpdated(){const t=this;t.hostUpdated&&(0,n.d)(t.hostUpdated,t),this._callbacks.hostUpdated.forEach(n.d)}triggerDestroy(){const t=this;t.hostDestroy&&(0,n.d)(t.hostDestroy,t),this._callbacks.hostDestroy.forEach(n.d)}triggerLifecycle(){const t=this;t.hostLifecycle&&this._callLifecycle((()=>t.hostLifecycle())),this._callbacks.hostLifecycle.forEach((t=>this._callLifecycle(t)))}_callLifecycle(e){t.internals.setAmbientComponent(this.component);const o=(0,n.d)(e);(Array.isArray(o)?o:[o]).forEach((t=>{"function"===typeof t?this._lifecycleDisconnected.push(t):"object"===typeof t&&"function"===typeof t.remove&&this._lifecycleDisconnected.push(t.remove)}))}};l=h,p.internals=new class{constructor(){this._ambientControllers=[],this.use=async(t,e)=>{const o=this.useRefSync(t);if(void 0===o){if("function"===typeof e){const t=new Error("Unable to resolve a controller from the provided value, so can't watch it's exports. ".concat(d));console.error(t)}return t}if(await o.ready,"function"===typeof e){if(void 0===o.watchExports)throw new Error("The controller must implement watchExports method to support watching exports");const t=o.watchExports((o=>e(o,t)))}return o.exports},this.useRef=async t=>{const e=this.useRefSync(t);if(void 0===e)throw new Error("Unable to resolve a controller from the provided value. ".concat(d));return await e.ready,e},this.useRefSync=t=>{const e=this.retrieveAmbientChildController();if(void 0!==e)return e;const o=u.internals.retrieveComponent().manager.internals.resolveExports(t);return void 0!==o?o:(t=>"object"===typeof t&&null!==t&&(h in t||"hostConnected"in t||"hostDisconnected"in t||"hostUpdate"in t||"hostUpdated"in t))(t)?t:void 0},this.shouldBypassSetter=!1,this.shouldBypassGetter=!1,this.shouldBypassReadonly=!1,this.elementToInstance=new WeakMap}setAmbientComponent(t){this._ambientComponent!==t&&(this._ambientComponent=t,queueMicrotask((()=>{this._ambientComponent===t&&(this._ambientComponent=void 0)})))}retrieveComponent(t){if(void 0===this._ambientComponent)throw new Error(["Unable to find out which component ".concat(t||"this"," controller "),"belongs to. This might happen if you tried to create a controller ","outside the component. If so, please wrap your controller ","definition in an arrow function, ","`const myController = ()=>makeController(...);` and call that","function inside the component `my = myController();`, or ","define your controller using makeGenericController/GenericController ","instead.\n","If you wish to use a controller inside an async controller, ","make sure you are using controller.use.\n","You might also have multiple instances of Controllers loaded"].join("\n"));return this._ambientComponent}setParentController(t){if(void 0===t)return void(this._ambientControllers=[]);const e=this._ambientControllers.indexOf(t);this._ambientControllers=-1===e?[...this._ambientControllers,t]:this._ambientControllers.slice(0,e+1),queueMicrotask((()=>{this._ambientControllers=[]}))}retrieveParentControllers(){return this._ambientControllers}setAmbientChildController(t){this._ambientChildController!==t&&(this._ambientChildController=t,queueMicrotask((()=>{this._ambientChildController===t&&(this._ambientChildController=void 0)})))}retrieveAmbientChildController(){const t=this._ambientChildController;return this._ambientChildController=void 0,t}};var u=p,y=class extends u{constructor(t){super(t)}watch(t,e){return super.watch(t,e)}dynamicGetSet(t,e){super.genericGetSet(t,e)}};function m(t){if("object"!==typeof t&&"function"!==typeof t||null===t)return t;const e=new Proxy(t,{get(t,o,n){if(!f.has(o)||!(o in t)||t[o]!==e)return o in t||o in Promise.prototype||"symbol"===typeof o?"function"===typeof t?t[o]:Reflect.get(t,o,n):void console.error('Trying to access "'.concat(o.toString(),"\" on the controller before it's loaded. ").concat(v))},set:(t,e,o,n)=>(console.error('Trying to set "'.concat(e.toString(),"\" on the controller before it's loaded. ").concat(v)),Reflect.set(t,e,o,n))});return e}var f=new Set(["exports","_exports"]),v="";var g=(t,e)=>e;function _(t,e,o){var s;const r=Object.keys(t),i=r.length;void 0===b&&queueMicrotask(C),null!==(s=b)&&void 0!==s||(b=new Map);let a=b.get(t);return void 0===a&&(a={callbacks:[],keyCount:i},b.set(t,a)),a.keyCount!==i&&(a.callbacks.forEach((t=>t(r))),a.callbacks=[],a.keyCount=i),a.callbacks.push((s=>{const r=t=>(0,n.d)(e,null,t),a=s[i];void 0===a?r(void 0):t[a]===o?r(a):r(void 0)})),o}var b=void 0;function C(){var t,e;Array.from(null!==(t=null===(e=b)||void 0===e?void 0:e.entries())&&void 0!==t?t:[]).forEach((t=>{let[e,{callbacks:o}]=t;const n=Object.keys(e);o.forEach((t=>t(n)))})),b=void 0}var w=class{constructor(t){this.enabledWatchers={},this.allWatchers={},this.trackKey=(t,e,o)=>{const n=Array.isArray(t)?t:[t];let s=n.length+1;const r=t=>{s-=1,void 0!==t&&(s=0),0===s&&e(t)};return n.forEach((t=>this.component.manager.trackPropertyKey(t,(e=>r(void 0===e?void 0:{key:e,host:t,type:"property",domValue:void 0})),o))),this.component.manager.trackPropKey(((t,e)=>{const o=void 0===t?void 0:c(this.component,t);r(void 0===t?void 0:{key:t,host:this.component,type:null!==o&&void 0!==o?o:"prop",domValue:"prop"===o?e:void 0})}),o),o},this.trackPropKey=(t,e)=>(this._trackedValue!==D&&this._trackedValue!==e&&this._firePropertyTrackers(void 0,void 0,void 0),0===this._keyTrackers.length&&queueMicrotask((()=>this._firePropertyTrackers(void 0,void 0,void 0))),this._trackedValue=e,this._keyTrackers.push(((o,s,r)=>(0,n.d)(t,void 0,e===s?o:void 0,r))),e),this._trackedValue=D,this._keyTrackers=[],this.getters={},this.setters={},this.accessorGetter={},this.accessorSetter={},this.reactiveUtilsIntegrations=new Set,this._exports=new WeakMap,Object.defineProperty(this,"component",{writable:!1,enumerable:!1,configurable:!0,value:t})}_firePropertyTrackers(t,e,o){const n=this._keyTrackers;this._trackedValue=D,this._keyTrackers=[],n.forEach((n=>n(t,e,o)))}getSetProxy(t,e,o){const n=this.component,s=n.constructor.prototype;if(this._getSetProxy(s,t,e,o,"class"),n.manager.isLit)return;const r=n.el.constructor.prototype;s!==r&&this._getSetProxy(r,t,e,o,"html")}_getSetProxy(t,e,o,n,s){const r=this.component,i=a(r,e),c=Object.getOwnPropertyDescriptor(t,e),l="html"===s;if(void 0===(null===c||void 0===c?void 0:c.set)||void 0===c.get){if(void 0!==c&&"value"in c)throw new Error('getSet() should only be used on @Prop/@property/@State/@state properties. For internal component properties, use regular get/set syntax. Tried to use it on "'.concat(e,'" in ').concat(r.el.tagName));if(l)return;throw new Error('Unable to find "'.concat(e,'" property on the ').concat(r.el.tagName," component"))}const{get:h,set:d}=c,p=!(L in h)&&o,y=!(L in d)&&n;if(!p&&!y)return;const m=p?function(){var t;let o=h.call(this);const n=u.internals.elementToInstance.get(this);if(u.internals.shouldBypassGetter||void 0===n)return o;const s=n.manager.internals;o=s.accessorGetter[e](o,e);const r=null!==(t=s.getters[e])&&void 0!==t?t:k;for(let i=0;i<r.length;i++)o=r[i](o,e);return o}:h,f=y?function(t){const o=h.call(this),n=u.internals.elementToInstance.get(this);if(void 0===n)return void d.call(this,t);let s=n.manager.isLit?t:function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:8;return null==t||"object"===typeof t||"function"===typeof t?t:0!==(4&e)?"false"!==t&&(""===t||!!t):0!==(2&e)?Number.parseFloat(t):0!==(1&e)?String(t):t}(t,i);const r=n.manager.internals;if(s===o)d.call(this,t);else{var a;const t=u.internals.shouldBypassSetter?k:null!==(a=r.setters[e])&&void 0!==a?a:k;for(let n=0;n<t.length&&(s=t[n](s,o,e),s!==o);n++);var c;if(s=r.accessorSetter[e](s,o,e),d.call(this,s),s!==o)null===(c=r.enabledWatchers[e])||void 0===c||c.forEach((t=>t(s,o,e)))}r._keyTrackers.length>0&&(null===r||void 0===r||r._firePropertyTrackers(e,t,o))}:d;p&&Object.defineProperty(m,L,{value:!0}),y&&Object.defineProperty(f,L,{value:!0}),Object.defineProperty(t,e,{...c,get:m,set:f})}markExports(t,e){("object"===typeof e&&null!==e||"function"===typeof e)&&this._exports.set(e,t)}resolveExports(t){return"object"===typeof t&&null!==t||"function"===typeof t?this._exports.get(t):void 0}},k=[],L=Symbol("controllersCustomAccessor"),D=Symbol("nothing"),x=(t,e)=>new P(t,e),P=class extends y{constructor(t,e){const o="addController"in t,r=new Set;const a=t;if(a.addController=function(e){var n;r.add(e),o&&!(h in e)&&t.el.isConnected&&(null===(n=e.hostConnected)||void 0===n||n.call(e))},a.removeController=function(t){var e;r.delete(t),null===(e=t.controllerRemoved)||void 0===e||e.call(t)},!o){const o=null!==e&&void 0!==e?e:t.constructor.__forceUpdate;a.requestUpdate=()=>o(t)}super(t),this.internals=new w(this.component),this.destroyed=!1,this._updatePromise=new n.D,this._originalLifecycles={},this.trackPropertyKey=_,this.trackPropKey=this.internals.trackPropKey,this.trackKey=this.internals.trackKey,this._readonlySetter=(t,e,o)=>{if(u.internals.shouldBypassReadonly)return t;const r=this.component;if("prop"===c(r,o))if(this.isLit){const t=s(r).get(o);t&&!1!==(null===t||void 0===t?void 0:t.attribute)&&r.el.setAttribute("string"===typeof t.attribute?t.attribute:(0,n.c)(o),String(e))}else r.requestUpdate();throw new Error('Cannot assign to read-only property "'.concat(o,'" of ').concat(r.el.tagName.toLowerCase(),'. Trying to assign "').concat(String(t),'"'))},this.devOnlySetPersistentControllerData=void 0,this.devOnlyGetPersistentControllerData=void 0,this.isLit=o,this.component.manager=this,function(t,e){if(e){const e=s(t);t.manager.internals.members=Object.fromEntries(Array.from(e,(t=>{let[e,{state:o,type:n}]=t;return[e,[o?32:n===Number?2:n===Boolean?4:1]]})))}else{var o,n;const e=t.constructor,s=null!==(o=null===(n=e.__registerControllers)||void 0===n?void 0:n.call(e,t))&&void 0!==o?o:void 0;if(e.__registerControllers=void 0,"object"!==typeof s)throw new Error("Failed to retrieve internal component meta. Make sure you have the useComponentsControllers() Rollup Plugin for Stencil Controllers configured in your Stencil config.");t.manager.internals.members=s}}(t,o),this._controllers=r,this.exports=void 0,this.hasDestroy="autoDestroyDisabled"in this.component&&"function"===typeof this.component.destroy,this.hasDestroy&&this.watch("autoDestroyDisabled",(()=>this._autoDestroyDisabledWatcher())),this._bindLifecycleMethods(),o||Object.defineProperty(t,"updateComplete",{get:async()=>await this._updatePromise.promise});const l=i(t),d=t.manager.internals;l.forEach((t=>{d.accessorGetter[t]=S,d.accessorSetter[t]=S,d.getSetProxy(t,!0,!0)})),u.internals.setParentController(void 0),u.internals.setAmbientComponent(t),u.internals.elementToInstance.set(t.el,t),u.internals.elementToInstance.set(t,t)}_bindLifecycleMethods(){const t=this.component,e=this.isLit,o=t.el===t;this._originalLifecycles={connectedCallback:e||o?void 0:t.connectedCallback,disconnectedCallback:e||o?void 0:t.disconnectedCallback,componentWillLoad:e?void 0:t.componentWillLoad,componentDidLoad:e?void 0:t.componentDidLoad,componentWillUpdate:e?void 0:t.componentWillUpdate,componentDidUpdate:e?void 0:t.componentDidUpdate,destroy:t.destroy};const n=this._connectedCallback.bind(this),s=this._disconnectedCallback.bind(this),r=this._update.bind(this),i=this._updated.bind(this);e?t.constructor.prototype.addController.call(t,{hostConnected:n,hostDisconnected:s,hostUpdate:r,hostUpdated:i}):(t.connectedCallback=n,t.disconnectedCallback=s,t.componentWillLoad=this._load.bind(this),t.componentDidLoad=this._loaded.bind(this),t.componentWillUpdate=r,t.componentDidUpdate=i),this.hasDestroy&&(t.destroy=this.destroy.bind(this))}ensureHasDestroy(){if(!this.hasDestroy)throw new Error(E)}_connectedCallback(){var t;if(this.destroyed){const t=this.component.el.tagName.toLowerCase();throw this.component.el.remove(),new Error("The ".concat(t," component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the autoDestroyDisabled prop."))}void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout),this.internals.enabledWatchers=this.internals.allWatchers,C(),this._controllers.forEach((t=>"triggerConnected"in t?t.triggerConnected():(0,n.d)(t.hostConnected,t))),null===(t=this._originalLifecycles.connectedCallback)||void 0===t||t.call(this.component)}_disconnectedCallback(){var t;this.destroyed||(this._controllers.forEach((t=>"triggerDisconnected"in t?t.triggerDisconnected():(0,n.d)(t.hostDisconnected,t))),null===(t=this._originalLifecycles.disconnectedCallback)||void 0===t||t.call(this.component),this.hasDestroy&&this._autoDestroyDisabledWatcher())}async _load(){var t;const e=this.internals.reactiveUtilsIntegrations;if(e.size>0)for(const o of e)"triggerLoad"in o?await o.triggerLoad():await(0,n.e)(o.hostLoad,o);await Promise.allSettled(Array.from(this._controllers,(async t=>e.has(t)?void 0:"triggerLoad"in t?await t.triggerLoad():await(0,n.e)(t.hostLoad,t)))),await(null===(t=this._originalLifecycles.componentWillLoad)||void 0===t?void 0:t.call(this.component))}_loaded(){var t;this._controllers.forEach((t=>"triggerLoaded"in t?t.triggerLoaded():(0,n.d)(t.hostLoaded,t))),null===(t=this._originalLifecycles.componentDidLoad)||void 0===t||t.call(this.component)}_update(){var t;this._controllers.forEach((t=>"triggerUpdate"in t?t.triggerUpdate():(0,n.d)(t.hostUpdate,t))),null===(t=this._originalLifecycles.componentWillUpdate)||void 0===t||t.call(this.component)}_updated(){var t;if(this._controllers.forEach((t=>"triggerUpdated"in t?t.triggerUpdated():(0,n.d)(t.hostUpdated,t))),null===(t=this._originalLifecycles.componentDidUpdate)||void 0===t||t.call(this.component),!this.isLit){const t=this._updatePromise;this._updatePromise=new n.D,t.resolve(!0)}}async destroy(){var t;if(this.ensureHasDestroy(),!this.destroyed){if(this.component.el.isConnected){this.hasDestroy=!1;try{this.component.el.remove()}finally{this.hasDestroy=!0}}this._autoDestroyTimeout=void 0,this.destroyed=!0,this._controllers.forEach((t=>"triggerDestroy"in t?t.triggerDestroy():(0,n.d)(t.hostDestroy,t))),this._controllers.clear(),await(null===(t=this._originalLifecycles.destroy)||void 0===t?void 0:t.call(this.component))}}_autoDestroyDisabledWatcher(){if(!this.component.el.isConnected&&!this.component.autoDestroyDisabled){void 0!==this._autoDestroyTimeout&&clearTimeout(this._autoDestroyTimeout);const t=()=>{this.destroy().catch(console.error)};this._autoDestroyTimeout=(0,n.f)(t,U)}}readonly(t){return this.getSet(t,{set:this._readonlySetter})}getSet(t,e){return this.component.manager.trackPropKey((o=>{var n,s,r;if(void 0===o)throw new Error("Unable to resolve get/set's prop name. Make sure you are using it like @Prop() someProp = this.manager.getSet(defaultValue,{get,set})");e.set===this._readonlySetter&&(null!==(r=(s=this.internals).readonlyProps)&&void 0!==r||(s.readonlyProps=new Set),this.internals.readonlyProps.add(o));const i=this.component,a=i[o],c=null===(n=e.initialSet)||void 0===n||n;if(null!=a&&a!==t&&"function"===typeof e.set&&c){const n=e.set(a,t,o);if(n!==a)if(this.isLit)i[o]=n;else{let t=!0;this.onConnected((()=>{t&&(t=!0,this.bypassSetter((()=>{i[o]=n})))}))}}this.genericGetSet(o,e)}),t)}},E="\nIf the component uses a controller that uses destroy() method, then the\ncomponent must have the following properties:\n".concat("autoDestroyDisabled and destroy","\n").trim(),U=1e3,S=t=>t,A=t=>function(){const e=u.internals.retrieveParentControllers();for(var o=arguments.length,n=new Array(o),s=0;s<o;s++)n[s]=arguments[s];const r=new t(...n),i=r.exports;u.internals.setParentController(e.at(-1));const a=r.component.manager.internals;a.markExports(r,i),r.watchExports((t=>a.markExports(r,t))),u.internals.setAmbientChildController(r);const c=[r.component,...e].reverse();return a.trackKey(c,(t=>void 0===t?void 0:function(t,e,o){let{host:n,key:s,type:r}=e;const i=n,a=i[s]!==t.exports,c=i[s]!==o,l=o!==t.exports;a&&!c&&l&&(i[s]=t.exports);if(n===t.component&&"prop"===r){const e=t.component.manager.internals;c&&e.markExports(t,i[s]),t.component.manager.watch(s,(o=>{o!==t.exports&&e.markExports(t,o)}))}t.watchExports((()=>{var e;if(i[s]===t.exports)return;const o=t.component.manager;!0===(null===(e=o.internals.readonlyProps)||void 0===e?void 0:e.has(s))?o.bypassReadonly((()=>{i[s]=t.exports})):i[s]=t.exports}))}(r,t,i)),i)};var T=t=>j(void 0,t),j=A(class extends u{constructor(t,e){super(t);const o=this.exports;try{u.internals.setAmbientComponent(this.component);const t=e(this.component,this),n=this.exports!==o;if(t instanceof Promise){n||this.setProvisionalExports(t);const e=t.then((t=>{this.exports=t,super.catchUpLifecycle()})).catch((t=>{this._ready.reject(t),console.error(t)}));this.onLoad((async()=>await e))}else n&&void 0===t||(this.exports=t),queueMicrotask((()=>super.catchUpLifecycle()))}catch(n){this._ready.reject(n),console.error(n)}}catchUpLifecycle(){}}),W=(t,e)=>(e,o)=>R(e,t,o),G=class extends y{constructor(t,e,o){super(t),this._loadAccessor=e,this._options=o,this.reactiveUtils=this.component.reactiveUtils,this._watchedProperties=new Map,this._isBinding={value:!0},this.setProvisionalExports(O.makeGetterProxy(t,this._watchedProperties,this._isBinding,this.constructor.allowedPropNameMismatches));const n=t.manager.internals.reactiveUtilsIntegrations;n.add(this);const s=Array.from(n).find((t=>t instanceof B));s&&n.delete(s),n.add(null!==s&&void 0!==s?s:new B(this.component)),t.manager.trackPropKey((t=>{t&&(this._instancePropName=t)}),this.exports)}hostConnected(){this._isBinding.value=!1}async hostLoad(){var t,e;const o=this.component;void 0===o.reactiveUtils?this.reactiveUtils=await(0,n.i)():this.reactiveUtils=await this.use(o.reactiveUtils);const s=O.gatherParameters(this,this._watchedProperties),r=null!==(t=null===(e=this._options)||void 0===e||null===(e=e.editConstructorProperties)||void 0===e?void 0:e.call(o,s))&&void 0!==t?t:s,i=r instanceof Promise?await r:r,a=o,c="string"===typeof this._instancePropName?a[this._instancePropName]:void 0;null!=c&&c!==this.exports?(this._instance=c,c.set(i)):this._instance=await this._createInstance(i),o.manager.destroyed||(O.watchComponentUpdates(this,this._instance,this._watchedProperties),O.watchAccessorUpdates(this,this._instance,this._watchedProperties),this.exports=this._instance)}async _createInstance(t){return this._isAccessorConstructor(this._loadAccessor)?new this._loadAccessor(t):await this._loadAccessor(t)}_isAccessorConstructor(t){return"prototype"in t&&"declaredClass"in t.prototype}hostDestroy(){this._instance&&this._instance.destroy()}async reCreate(){this.hostDestroy(),await this.hostLoad()}},R=A(G),O={makeGetterProxy:(t,e,o,n)=>new Proxy({},{has:(t,e)=>"string"===typeof e||e in t,get:(n,s)=>{var r;const i=Reflect.get(n,s);if("symbol"===typeof s||s in Promise.prototype)return i;const a=s in n,c=null===(r=null===o||void 0===o?void 0:o.value)||void 0===r||r;return a||!c?i:t.manager.trackKey(t,(t=>{void 0!==t&&e.set(t.key,s)}),i)}}),watchComponentUpdates(t,e,o){function n(t,n){const s=o.get(n),r=e[s];return"boolean"===typeof r&&s!==n&&n.toLowerCase().includes("disable")?!r:r}const s=(t,n,s)=>{const r=o.get(s),i=e[r],a="boolean"===typeof i&&r!==s&&s.toLowerCase().includes("disable");if((a?!i:i)===t)return t;e[r]=a?!t:t;const c=e[r];return a?!c:c},r=t.component.manager.internals;o.forEach(((t,e)=>{r.accessorGetter[e]=n,r.accessorSetter[e]=s}))},watchAccessorUpdates(t,e,o){const{component:n}=t,s=n,r=e,i=function(t){var e,o;const n=t,s=Object.entries(null!==(e=null===(o=n.__accessor__)||void 0===o?void 0:o.metadata)&&void 0!==e?e:{});return new Set(s.filter((t=>{let[e,o]=t;return!0===(null===o||void 0===o?void 0:o.readOnly)})).map((t=>{let[e]=t;return e})))}(e);n.manager.bypassGetter((()=>o.forEach(((t,e)=>{if(i.has(t))return;const o=s[e],n=r[t],a="boolean"===typeof o&&t!==e&&e.toLowerCase().includes("disable")?!o:o;null!=a&&n!==a&&(r[t]=a)})))),t.onLifecycle((()=>{if(!e.destroyed)return Array.from(o,(e=>{let[o,i]=e;return t.reactiveUtils.watch((()=>r[i]),(()=>{const t=r[i],e="boolean"===typeof t&&i!==o&&o.toLowerCase().includes("disable")?!t:t;n.manager.bypassSetter((()=>{s[o]=e}))}),{initial:!0})}))}))},gatherParameters(t,e){const{component:o}=t;return Object.fromEntries(Array.from(e,(t=>{let[e,n]=t;return[n,o[e]]})).filter((t=>{let[,e]=t;return void 0!==e})))},reEmitAccessorEvents(t,e,o,s){if(!("on"in e&&"function"===typeof e.on))return;const r=Object.entries(t.component).map((t=>{let[e,o]=t;const r=o;if(!e.startsWith(s)||e===s||"object"!==typeof r||null===r||!("emit"in r)||"function"!==typeof r.emit)return;const i=r.emit,a=e.slice(s.length);return[(0,n.c)(a).toLowerCase(),i]})).filter(n.k);if(0===r.length)return;const i=e,a=()=>i;t.onLifecycle((()=>{if(!e.destroyed)return r.map((t=>{let[e,n]=t;return o.on(a,e,n)}))}))},async reCreate(t,e){const o=e.manager.useRefSync(t);void 0!==o&&await o.reCreate()}};var M=Promise.all([(0,n.h)(),(0,n.j)()]),B=class extends y{async hostLoad(){const[t,{subclass:e,property:o}]=await M;class n extends t{}const s=(t,e)=>d[e];function r(t,e,o){return void 0!==d&&(d[o]=t),t}const a=this.component,c=a.manager.internals,l=[],h=i(this.component);if(a.manager.bypassGetter((()=>h.forEach((t=>{c.accessorSetter[t]!==S||(l.push(t),c.accessorGetter[t]=s,c.accessorSetter[t]=r,o({value:a[t]})(n.prototype,t))})))),this._enabledMembers=l,0===l.length)return;const d=new(e(a.el.tagName)(n));this._instance=d}controllerRemoved(){var t,e;super.controllerRemoved();const o=this.component.manager.internals;null===(t=this._instance)||void 0===t||t.destroy(),null===(e=this._enabledMembers)||void 0===e||e.forEach((t=>{o.accessorGetter[t]=S,o.accessorSetter[t]=S}))}}}}]);
//# sourceMappingURL=34872.1018af3c.chunk.js.map