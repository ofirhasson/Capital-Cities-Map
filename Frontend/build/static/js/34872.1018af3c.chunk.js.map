{"version":3,"file":"static/js/34872.1018af3c.chunk.js","mappings":"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","sources":["../node_modules/@arcgis/map-components/dist/esm/index-c99fc80c.js"],"sourcesContent":["/*!\n * All material copyright Esri, All Rights Reserved, unless otherwise specified.\n * See https://js.arcgis.com/4.30/esri/copyright.txt for details.\n * v4.30.7\n */\nimport { D as Deferred, c as camelToKebab, d as safeCall, e as safeAsyncCall, f as devToolsAwareTimeout, h as importCoreAccessor, j as importCoreAccessorSupportDecorators, k as isNotUndefined, i as importCoreReactiveUtils } from './index-d2df902e.js';\n\n// src/framework.ts\nfunction retrieveComponentMembers(component, isLit) {\n  if (isLit) {\n    const elementProperties = getLitProperties(component);\n    component.manager.internals.members = Object.fromEntries(\n      Array.from(elementProperties, ([name, { state, type }]) => [\n        name,\n        [\n          state ? 32 /* State */ : type === Number ? 2 /* Number */ : type === Boolean ? 4 /* Boolean */ : 1 /* String */\n        ]\n      ])\n    );\n  } else {\n    const constructor = component.constructor;\n    const members = constructor.__registerControllers?.(component) ?? void 0;\n    constructor.__registerControllers = void 0;\n    if (typeof members !== \"object\") {\n      throw new Error(\n        \"Failed to retrieve internal component meta. Make sure you have the useComponentsControllers() Rollup Plugin for Stencil Controllers configured in your Stencil config.\"\n      );\n    }\n    component.manager.internals.members = members;\n  }\n}\nvar getLitProperties = (component) => component.constructor.elementProperties;\nfunction parsePropertyValue(value, type = 8 /* Any */) {\n  const isComplex = value == null || typeof value === \"object\" || typeof value === \"function\";\n  if (isComplex) {\n    return value;\n  }\n  if ((type & 4 /* Boolean */) !== 0) {\n    return value === \"false\" ? false : value === \"\" || !!value;\n  } else if ((type & 2 /* Number */) !== 0) {\n    return Number.parseFloat(value);\n  } else if ((type & 1 /* String */) !== 0) {\n    return String(value);\n  } else {\n    return value;\n  }\n}\nvar makeMemberFilter = (filter) => (component) => {\n  const members = component.manager.internals.members;\n  return Object.entries(members ?? {}).filter(([_name, [propType]]) => (propType & filter) !== 0).map(([name]) => name);\n};\nvar getPropLikeMembers = makeMemberFilter(63 /* PropLike */);\nvar getMemberType = (component, name) => component.manager.internals.members?.[name]?.[0];\nfunction getPropType(component, name) {\n  const type = getMemberType(component, name);\n  if (type === void 0) {\n    return void 0;\n  } else if (type & 32 /* State */) {\n    return \"state\";\n  } else {\n    return \"prop\";\n  }\n}\n\n// src/types.ts\nvar controllerSymbol = Symbol(\"controller\");\n\n// src/utils.ts\nvar isController = (value) => typeof value === \"object\" && value !== null && (controllerSymbol in value || \"hostConnected\" in value || \"hostDisconnected\" in value || \"hostUpdate\" in value || \"hostUpdated\" in value);\n\n// src/ControllerInternals.ts\nvar ControllerInternals = class {\n  constructor() {\n    this._ambientControllers = [];\n    /**\n     * The type definition has to be duplicated due to the\n     * \"'use' is referenced directly or indirectly in its own type annotation.\"\n     * error\n     */\n    this.use = async (value, watchExports) => {\n      const controller = this.useRefSync(value);\n      if (controller === void 0) {\n        if (typeof watchExports === \"function\") {\n          const error = new Error(\n            `Unable to resolve a controller from the provided value, so can't watch it's exports. ${unresolvableExports}`\n          );\n          {\n            console.error(error);\n          }\n        }\n        return value;\n      }\n      await controller.ready;\n      if (typeof watchExports === \"function\") {\n        if (controller.watchExports === void 0) {\n          throw new Error(`The controller must implement watchExports method to support watching exports`);\n        }\n        const unsubscribe = controller.watchExports(\n          (exports) => watchExports(exports, unsubscribe)\n        );\n      }\n      return controller.exports;\n    };\n    this.useRef = async (value) => {\n      const controller = this.useRefSync(value);\n      if (controller === void 0) {\n        throw new Error(`Unable to resolve a controller from the provided value. ${unresolvableExports}`);\n      }\n      await controller.ready;\n      return controller;\n    };\n    this.useRefSync = (value) => {\n      const ambientChildController = this.retrieveAmbientChildController();\n      if (ambientChildController !== void 0) {\n        return ambientChildController;\n      }\n      const component = Controller.internals.retrieveComponent();\n      const controller = component.manager.internals.resolveExports(value);\n      if (controller !== void 0) {\n        return controller;\n      }\n      if (isController(value)) {\n        return value;\n      }\n      return void 0;\n    };\n    this.shouldBypassSetter = false;\n    this.shouldBypassGetter = false;\n    this.shouldBypassReadonly = false;\n    /**\n     * A map from component instance or component element to component instance.\n     * To get from component instance or component element to component element,\n     * you can just use the .el property\n     */\n    this.elementToInstance = /* @__PURE__ */ new WeakMap();\n  }\n  /*\n   * Allow controllers to implicitly retrieve which component they are in, to\n   * improve DX (avoids the need to pass \"this\" explicitly for each controller)\n   */\n  setAmbientComponent(component) {\n    if (this._ambientComponent === component) {\n      return;\n    }\n    this._ambientComponent = component;\n    queueMicrotask(() => {\n      if (this._ambientComponent === component) {\n        this._ambientComponent = void 0;\n      }\n    });\n  }\n  retrieveComponent(name) {\n    if (this._ambientComponent === void 0) {\n      throw new Error(\n        [\n          `Unable to find out which component ${name || \"this\"} controller `,\n          \"belongs to. This might happen if you tried to create a controller \",\n          \"outside the component. If so, please wrap your controller \",\n          \"definition in an arrow function, \",\n          \"`const myController = ()=>makeController(...);` and call that\",\n          \"function inside the component `my = myController();`, or \",\n          \"define your controller using makeGenericController/GenericController \",\n          \"instead.\\n\",\n          \"If you wish to use a controller inside an async controller, \",\n          \"make sure you are using controller.use.\\n\",\n          \"You might also have multiple instances of Controllers loaded\"\n        ].join(\"\\n\")\n      );\n    }\n    return this._ambientComponent;\n  }\n  /*\n   * Aids proxyExports() in knowing who is it's host\n   */\n  setParentController(controller) {\n    if (controller === void 0) {\n      this._ambientControllers = [];\n      return;\n    }\n    const index = this._ambientControllers.indexOf(controller);\n    this._ambientControllers = index === -1 ? [...this._ambientControllers, controller] : this._ambientControllers.slice(0, index + 1);\n    queueMicrotask(() => {\n      this._ambientControllers = [];\n    });\n  }\n  retrieveParentControllers() {\n    return this._ambientControllers;\n  }\n  /*\n   * Aids controller.use in retrieving controller value when it receives\n   * controller exports, rather than the controller itself\n   */\n  setAmbientChildController(controller) {\n    if (this._ambientChildController === controller) {\n      return;\n    }\n    this._ambientChildController = controller;\n    queueMicrotask(() => {\n      if (this._ambientChildController === controller) {\n        this._ambientChildController = void 0;\n      }\n    });\n  }\n  retrieveAmbientChildController() {\n    const controller = this._ambientChildController;\n    this._ambientChildController = void 0;\n    return controller;\n  }\n};\nvar unresolvableExports = [\n  \"The value you passed is not a controller and not a controller exports. If \",\n  \"your controller exports a literal value, try making your controller export \",\n  \"an object instead\"\n].join(\"\");\n\n// src/Controller.ts\nvar _a;\nvar _Controller = class _Controller {\n  constructor(component) {\n    this._callbacks = {\n      hostConnected: [],\n      hostDisconnected: [],\n      hostLoad: [],\n      hostLoaded: [],\n      hostUpdate: [],\n      hostUpdated: [],\n      hostDestroy: [],\n      hostLifecycle: []\n    };\n    this._ready = new Deferred();\n    this._lifecycleDisconnected = [];\n    this.connectedCalled = false;\n    this.willLoadCalled = false;\n    this.didLoadCalled = false;\n    this[_a] = true;\n    this.ready = this._ready.promise;\n    /*\n     * Setting default exports to \"this\" so that controllers that don't use\n     * exports/proxyExports(), could still be used as if they did\n     * (i.e with controller.use)\n     */\n    this._exports = makeProvisionalValue(this);\n    this._exportWatchers = /* @__PURE__ */ new Set();\n    const resolvedComponent = toControllerHost(\n      component ?? _Controller.internals.retrieveComponent(new.target.name)\n    );\n    Object.defineProperty(this, \"component\", {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: resolvedComponent\n    });\n    this.component.addController(this);\n    _Controller.internals.setParentController(this);\n    if (\"hostDestroy\" in this) {\n      this.component.manager.ensureHasDestroy();\n    }\n    const manager = this.component.manager;\n    const isInControllerManager = manager === void 0;\n    if (!isInControllerManager) {\n      queueMicrotask(() => this.catchUpLifecycle());\n    }\n  }\n  /**\n   * If controller is being added dynamically, after the component\n   * construction, then trigger connected and load right away\n   */\n  catchUpLifecycle() {\n    const { manager } = this.component;\n    const connectedWillStillHappen = !manager.connectedCalled;\n    if (!connectedWillStillHappen && !this.connectedCalled) {\n      this.triggerConnected();\n    }\n    const loadWillStillHappen = !manager.willLoadCalled;\n    if (loadWillStillHappen) {\n      return;\n    }\n    this.triggerLoad().then(() => {\n      const loadedWillStillHappen = !manager.didLoadCalled;\n      if (loadedWillStillHappen) {\n        return;\n      }\n      this.triggerLoaded();\n    }).catch(console.error);\n  }\n  get exports() {\n    return this._exports;\n  }\n  /**\n   * Set controller's exports property (for usage with proxyExports()) and mark\n   * controller as ready (for usage in other controllers). Also, triggers\n   * re-render of the component\n   */\n  set exports(exports) {\n    if (this._exports !== exports) {\n      this._exports = exports;\n      if (this.connectedCalled) {\n        this.component.requestUpdate();\n      }\n      this._exportWatchers.forEach(safeCall);\n    }\n    this._ready.resolve(exports);\n  }\n  setProvisionalExports(exports) {\n    this._exports = makeProvisionalValue(exports);\n    this._exportWatchers.forEach(safeCall);\n  }\n  watchExports(callback) {\n    const safeCallback = () => callback(this._exports);\n    this._exportWatchers.add(safeCallback);\n    return () => void this._exportWatchers.delete(safeCallback);\n  }\n  /**\n   * A flexible utility for making sure a controller is loaded before it's used,\n   * regardless of how or where a controller was defined:\n   *\n   * @example\n   * makeGenericController(async (component, controller) => {\n   *   // Await some controller from the component:\n   *   await controller.use(component.someController);\n   *   // Initialize new controllers\n   *   await controller.use(load(importCoreReactiveUtils));\n   *   await controller.use(new ViewModelController(component,newWidgetsHomeHomeViewModel));\n   *   await controller.use(someController(component));\n   * });\n   *\n   * @remarks\n   * If your controller is not async, and you are not creating it async, then\n   * you are not required to use controller.use - you can use it directly.\n   * Similarly, accessing controllers after componentWillLoad callback does not\n   * require awaiting them as they are guaranteed to be loaded by then.\n   */\n  get use() {\n    _Controller.internals.setAmbientComponent(this.component);\n    return _Controller.internals.use;\n  }\n  /**\n   * Just like controller.use, but returns the controller itself, rather than it's\n   * exports\n   *\n   * Use cases:\n   * - You have a controller and you want to make sure it's loaded before you\n   *   try to use it\n   * - Your controller is not using exports, so you wish to access some props on\n   *   it directly\n   * - You have a controller exports only, and you want to retrieve the\n   *   controller itself. This is useful if you wish to call .watchExports() or\n   *   some other method on the controller\n   */\n  get useRef() {\n    _Controller.internals.setAmbientComponent(this.component);\n    return _Controller.internals.useRef;\n  }\n  /**\n   * Like useRef, but doesn't wait for the controller to get ready\n   */\n  get useRefSync() {\n    _Controller.internals.setAmbientComponent(this.component);\n    return _Controller.internals.useRefSync;\n  }\n  /**\n   * If you need to set a prop/state without triggering the custom setter you\n   * defined with getSet()/dynamicGetSet()/readonly(), set the value inside\n   * of this function\n   *\n   * @example\n   * @Prop() readOnly = this.manager.readOnly(true);\n   *\n   * someAction(): void {\n   *   this.manager.bypassSetter(()=>{\n   *     this.readOnly = false;\n   *   });\n   * }\n   *\n   */\n  bypassSetter(callback) {\n    _Controller.internals.shouldBypassSetter = true;\n    try {\n      return callback();\n    } finally {\n      _Controller.internals.shouldBypassSetter = false;\n    }\n  }\n  /**\n   * Like bypassSetter, but only bypasses this.manager.readonly(), rather that\n   * all setters set using this.manager.getSet()\n   */\n  bypassReadonly(callback) {\n    _Controller.internals.shouldBypassReadonly = true;\n    try {\n      return callback();\n    } finally {\n      _Controller.internals.shouldBypassReadonly = false;\n    }\n  }\n  /**\n   * Property reads inside of this function will bypass any custom getter you\n   * may have, and read the value directly from what's stored in Stencil/Lit.\n   *\n   * This also bypasses reactiveUtils integration - reading a property inside of\n   * bypassGetter won't make that property tracked.\n   *\n   * @example\n   * reactiveUtils.watch(\n   *   ()=>{\n   *     this.manager.bypassGetter(()=>{\n   *       console.log(this.someProp);\n   *     });\n   *     return this.prop;\n   *   },\n   *   console.log\n   * )\n   */\n  bypassGetter(callback) {\n    _Controller.internals.shouldBypassGetter = true;\n    try {\n      return callback();\n    } finally {\n      _Controller.internals.shouldBypassGetter = false;\n    }\n  }\n  /**\n   * Like this.manager.getSet(), but can be called on any component's\n   * state/prop from anywhere, rather than just from the default value\n   */\n  dynamicGetSet(name, getSet) {\n    this.genericGetSet(name, getSet);\n  }\n  /**\n   * Like dynamicGetSet, but less type-safe. Useful in cases when trying to set\n   * getters/setters in place where property names & types are not known\n   * statically\n   */\n  genericGetSet(property, getSet) {\n    var _a2, _b;\n    const genericGetSet = getSet;\n    const internals = this.component.manager.internals;\n    if (typeof genericGetSet.get === \"function\") {\n      (_a2 = internals.getters)[property] ?? (_a2[property] = []);\n      internals.getters[property].unshift(genericGetSet.get);\n    }\n    const set = genericGetSet.set === \"ignore\" ? ignoreSet : genericGetSet.set;\n    if (set) {\n      (_b = internals.setters)[property] ?? (_b[property] = []);\n      internals.setters[property].unshift(set);\n    }\n  }\n  // FEATURE: improve typings\n  /**\n   * Dynamically set a watcher for any reactive property\n   */\n  watch(property, callback) {\n    var _a2;\n    const type = getMemberType(this.component, property);\n    if (type === void 0) {\n      throw new Error(\n        `Trying to watch a non-@property, non-@state property \"${property}\". Either convert it into a @state() or use get/set syntax`\n      );\n    }\n    const internals = this.component.manager.internals;\n    (_a2 = internals.allWatchers)[property] ?? (_a2[property] = []);\n    const watchers = internals.allWatchers[property];\n    const genericCallback = callback;\n    const safeCallback = (newValue, oldValue, propertyName) => safeCall(genericCallback, null, newValue, oldValue, propertyName);\n    watchers.push(safeCallback);\n    return () => {\n      const index = watchers.indexOf(safeCallback);\n      if (index !== -1) {\n        watchers.splice(index, 1);\n      }\n    };\n  }\n  controllerRemoved() {\n    if (this.component.el.isConnected) {\n      this.triggerDisconnected();\n    }\n    this.triggerDestroy();\n  }\n  // Register a lifecycle callback\n  onConnected(callback) {\n    this._callbacks.hostConnected.push(callback);\n  }\n  onDisconnected(callback) {\n    this._callbacks.hostDisconnected.push(callback);\n  }\n  onLoad(callback) {\n    this._callbacks.hostLoad.push(callback);\n  }\n  onLoaded(callback) {\n    this._callbacks.hostLoaded.push(callback);\n  }\n  onUpdate(callback) {\n    this._callbacks.hostUpdate.push(callback);\n  }\n  onUpdated(callback) {\n    this._callbacks.hostUpdated.push(callback);\n  }\n  onDestroy(callback) {\n    this.component.manager.ensureHasDestroy();\n    this._callbacks.hostDestroy.push(callback);\n  }\n  onLifecycle(callback) {\n    this._callbacks.hostLifecycle.push(callback);\n    if (this.connectedCalled && this.component.el.isConnected) {\n      this._callLifecycle(callback);\n    }\n  }\n  // Call each lifecycle hook\n  triggerConnected() {\n    const genericController = this;\n    if (genericController.hostConnected) {\n      safeCall(genericController.hostConnected, genericController);\n    }\n    this._callbacks.hostConnected.forEach(safeCall);\n    this.triggerLifecycle();\n    this.connectedCalled = true;\n  }\n  triggerDisconnected() {\n    const genericController = this;\n    if (genericController.hostDisconnected) {\n      safeCall(genericController.hostDisconnected, genericController);\n    }\n    this._callbacks.hostDisconnected.forEach(safeCall);\n    this._lifecycleDisconnected.forEach(safeCall);\n    this._lifecycleDisconnected = [];\n  }\n  async triggerLoad() {\n    if (this.willLoadCalled) {\n      return;\n    }\n    this.willLoadCalled = true;\n    const genericController = this;\n    if (genericController.hostLoad) {\n      await safeAsyncCall(genericController.hostLoad, genericController);\n    }\n    if (this._callbacks.hostLoad.length > 0) {\n      await Promise.allSettled(this._callbacks.hostLoad.map(safeAsyncCall));\n    }\n    this._ready.resolve(this._exports);\n  }\n  triggerLoaded() {\n    if (this.didLoadCalled) {\n      return;\n    }\n    const genericController = this;\n    if (genericController.hostLoaded) {\n      safeCall(genericController.hostLoaded, genericController);\n    }\n    this._callbacks.hostLoaded.forEach(safeCall);\n    this.didLoadCalled = true;\n  }\n  triggerUpdate() {\n    const genericController = this;\n    if (genericController.hostUpdate) {\n      safeCall(genericController.hostUpdate, genericController);\n    }\n    this._callbacks.hostUpdate.forEach(safeCall);\n  }\n  triggerUpdated() {\n    const genericController = this;\n    if (genericController.hostUpdated) {\n      safeCall(genericController.hostUpdated, genericController);\n    }\n    this._callbacks.hostUpdated.forEach(safeCall);\n  }\n  triggerDestroy() {\n    const genericController = this;\n    if (genericController.hostDestroy) {\n      safeCall(genericController.hostDestroy, genericController);\n    }\n    this._callbacks.hostDestroy.forEach(safeCall);\n  }\n  triggerLifecycle() {\n    const genericController = this;\n    if (genericController.hostLifecycle) {\n      this._callLifecycle(() => genericController.hostLifecycle());\n    }\n    this._callbacks.hostLifecycle.forEach((callback) => this._callLifecycle(callback));\n  }\n  _callLifecycle(callback) {\n    _Controller.internals.setAmbientComponent(this.component);\n    const cleanupRaw = safeCall(callback);\n    const cleanup = Array.isArray(cleanupRaw) ? cleanupRaw : [cleanupRaw];\n    cleanup.forEach((cleanup2) => {\n      if (typeof cleanup2 === \"function\") {\n        this._lifecycleDisconnected.push(cleanup2);\n      } else if (typeof cleanup2 === \"object\" && typeof cleanup2.remove === \"function\") {\n        this._lifecycleDisconnected.push(cleanup2.remove);\n      }\n    });\n  }\n};\n_a = controllerSymbol;\n_Controller.internals = new ControllerInternals();\nvar Controller = _Controller;\nvar GenericController = class extends Controller {\n  // Redundant constructor needed to improve typing\n  constructor(component) {\n    super(component);\n  }\n  // Overriding super's watch only to improve typing\n  watch(property, callback) {\n    return super.watch(\n      property,\n      callback\n    );\n  }\n  dynamicGetSet(property, getSet) {\n    super.genericGetSet(property, getSet);\n  }\n};\nfunction makeProvisionalValue(base) {\n  if (typeof base !== \"object\" && typeof base !== \"function\" || base === null) {\n    return base;\n  }\n  const proxy2 = new Proxy(base, {\n    get(target, prop, receiver) {\n      if (cyclical.has(prop) && prop in target && target[prop] === proxy2) {\n        return void 0;\n      }\n      if (prop in target || prop in Promise.prototype || typeof prop === \"symbol\") {\n        return typeof target === \"function\" ? target[prop] : Reflect.get(target, prop, receiver);\n      }\n      console.error(`Trying to access \"${prop.toString()}\" on the controller before it's loaded. ${accessBeforeLoad}`);\n      return void 0;\n    },\n    set(target, prop, newValue, receiver) {\n      console.error(`Trying to set \"${prop.toString()}\" on the controller before it's loaded. ${accessBeforeLoad}`);\n      return Reflect.set(target, prop, newValue, receiver);\n    }\n  });\n  return proxy2;\n}\nvar cyclical = /* @__PURE__ */ new Set([\"exports\", \"_exports\"]);\nvar accessBeforeLoad = \"\" ;\nfunction toControllerHost(component) {\n  if (\"addController\" in component) {\n    return component;\n  } else {\n    throw new Error(\n      \"Component does not implement ControllerHost. This might be because you forgot to add 'manager: Controller<this> = useControllerManager(this);' in your component, or you tried to use some controller before that line\"\n    );\n  }\n}\nvar ignoreSet = (_, value) => value;\nfunction trackPropertyKey(object, onResolved, defaultValue) {\n  const keys = Object.keys(object);\n  const keyCount = keys.length;\n  if (keyTrackMap === void 0) {\n    queueMicrotask(keyTrackResolve);\n  }\n  keyTrackMap ?? (keyTrackMap = /* @__PURE__ */ new Map());\n  let pendingTrackers = keyTrackMap.get(object);\n  if (pendingTrackers === void 0) {\n    pendingTrackers = { callbacks: [], keyCount };\n    keyTrackMap.set(object, pendingTrackers);\n  }\n  if (pendingTrackers.keyCount !== keyCount) {\n    pendingTrackers.callbacks.forEach((resolve) => resolve(keys));\n    pendingTrackers.callbacks = [];\n    pendingTrackers.keyCount = keyCount;\n  }\n  pendingTrackers.callbacks.push((keys2) => {\n    const callback = (key2) => safeCall(onResolved, null, key2);\n    const key = keys2[keyCount];\n    if (key === void 0) {\n      callback(void 0);\n    } else if (object[key] === defaultValue) {\n      callback(key);\n    } else {\n      callback(void 0);\n    }\n  });\n  return defaultValue;\n}\nvar keyTrackMap = void 0;\nfunction keyTrackResolve() {\n  Array.from(keyTrackMap?.entries() ?? []).forEach(([object, { callbacks }]) => {\n    const keys = Object.keys(object);\n    callbacks.forEach((commit) => commit(keys));\n  });\n  keyTrackMap = void 0;\n}\nvar ComponentInternals = class {\n  constructor(component) {\n    /**\n     * When watchers are set, set then into `allWatchers`. When watchers are read\n     * in the setter, read from `enabledWatchers`.\n     * On connectedCallback(), controller manager does `enabledWatchers=allWatchers`.\n     * Reasoning:\n     * - This disables watchers until connected callback (matches behavior of\n     *   Stencil's watchers)\n     * - This removes in the setter to check if watchers were enabled already or\n     *   not (as getters/setters are hot path, and should be streamlined)\n     */\n    this.enabledWatchers = {};\n    this.allWatchers = {};\n    this.trackKey = (hostsCandidates, onResolved, defaultValue) => {\n      const candidateHosts = Array.isArray(hostsCandidates) ? hostsCandidates : [hostsCandidates];\n      let leftToResolve = candidateHosts.length + 1;\n      const resolved = (resolution) => {\n        leftToResolve -= 1;\n        if (resolution !== void 0) {\n          leftToResolve = 0;\n        }\n        if (leftToResolve === 0) {\n          onResolved(resolution);\n        }\n      };\n      candidateHosts.forEach(\n        (host) => this.component.manager.trackPropertyKey(\n          host,\n          (key) => resolved(\n            key === void 0 ? void 0 : {\n              key,\n              host,\n              type: \"property\",\n              domValue: void 0\n            }\n          ),\n          defaultValue\n        )\n      );\n      this.component.manager.trackPropKey((key, domValue) => {\n        const propType = key === void 0 ? void 0 : getPropType(this.component, key);\n        resolved(\n          key === void 0 ? void 0 : {\n            key,\n            host: this.component,\n            type: propType ?? \"prop\",\n            domValue: propType === \"prop\" ? domValue : void 0\n          }\n        );\n      }, defaultValue);\n      return defaultValue;\n    };\n    this.trackPropKey = (onResolved, defaultValue) => {\n      if (this._trackedValue !== nothing && this._trackedValue !== defaultValue) {\n        this._firePropertyTrackers(void 0, void 0, void 0);\n      }\n      if (this._keyTrackers.length === 0) {\n        queueMicrotask(() => this._firePropertyTrackers(void 0, void 0, void 0));\n      }\n      this._trackedValue = defaultValue;\n      this._keyTrackers.push(\n        (key, value, previousValue) => safeCall(onResolved, void 0, defaultValue === value ? key : void 0, previousValue)\n      );\n      return defaultValue;\n    };\n    this._trackedValue = nothing;\n    this._keyTrackers = [];\n    this.getters = {};\n    this.setters = {};\n    this.accessorGetter = {};\n    this.accessorSetter = {};\n    this.reactiveUtilsIntegrations = /* @__PURE__ */ new Set();\n    this._exports = /* @__PURE__ */ new WeakMap();\n    Object.defineProperty(this, \"component\", {\n      writable: false,\n      enumerable: false,\n      configurable: true,\n      value: component\n    });\n  }\n  _firePropertyTrackers(key, value, oldValue) {\n    const trackers = this._keyTrackers;\n    this._trackedValue = nothing;\n    this._keyTrackers = [];\n    trackers.forEach((tracker) => tracker(key, value, oldValue));\n  }\n  /**\n   * Configure a getter or setter for a given \\@Prop/\\@State\n   *\n   * Note, since props are defined on the prototype, they are shared between all\n   * instances of a component. Thus, instead of passing a reference to the\n   * getter/setter function, you should update the\n   * ComponentInternals.getters/setters properties, and then call getSetProxy\n   * to apply the changes to the prototype\n   */\n  getSetProxy(property, hasGetter, hasSetter) {\n    const component = this.component;\n    const classPrototype = component.constructor.prototype;\n    this._getSetProxy(classPrototype, property, hasGetter, hasSetter, \"class\");\n    if (component.manager.isLit) {\n      return;\n    }\n    const htmlPrototype = component.el.constructor.prototype;\n    if (classPrototype !== htmlPrototype) {\n      this._getSetProxy(htmlPrototype, property, hasGetter, hasSetter, \"html\");\n    }\n  }\n  _getSetProxy(prototype, name, hasGetter, hasSetter, type) {\n    const component = this.component;\n    const propType = getMemberType(component, name);\n    const descriptor = Object.getOwnPropertyDescriptor(prototype, name);\n    const tolerateNotFound = type === \"html\";\n    if (descriptor?.set === void 0 || descriptor.get === void 0) {\n      if (descriptor !== void 0 && \"value\" in descriptor) {\n        throw new Error(\n          `getSet() should only be used on @Prop/@property/@State/@state properties. For internal component properties, use regular get/set syntax. Tried to use it on \"${name}\" in ${component.el.tagName}`\n        );\n      } else if (tolerateNotFound) {\n        return;\n      } else {\n        throw new Error(`Unable to find \"${name}\" property on the ${component.el.tagName} component`);\n      }\n    }\n    const { get: originalGet, set: originalSet } = descriptor;\n    const isGetterAlreadyOverwritten = customAccessor in originalGet;\n    const isSetterAlreadyOverwritten = customAccessor in originalSet;\n    const shouldOverwriteGet = !isGetterAlreadyOverwritten && hasGetter;\n    const shouldOverwriteSet = !isSetterAlreadyOverwritten && hasSetter;\n    if (!shouldOverwriteGet && !shouldOverwriteSet) {\n      return;\n    }\n    const finalGetter = shouldOverwriteGet ? function getter() {\n      let value = originalGet.call(this);\n      const component2 = Controller.internals.elementToInstance.get(this);\n      if (Controller.internals.shouldBypassGetter || component2 === void 0) {\n        return value;\n      }\n      const internals = component2.manager.internals;\n      value = internals.accessorGetter[name](value, name);\n      const getters = internals.getters[name] ?? emptyArray;\n      for (let i = 0; i < getters.length; i++) {\n        value = getters[i](value, name);\n      }\n      return value;\n    } : originalGet;\n    const finalSetter = shouldOverwriteSet ? function setter(rawNewValue) {\n      const oldValue = originalGet.call(this);\n      const component2 = Controller.internals.elementToInstance.get(this);\n      if (component2 === void 0) {\n        originalSet.call(this, rawNewValue);\n        return;\n      }\n      let newValue = component2.manager.isLit ? rawNewValue : parsePropertyValue(rawNewValue, propType);\n      const internals = component2.manager.internals;\n      if (newValue === oldValue) {\n        originalSet.call(this, rawNewValue);\n      } else {\n        const setters = Controller.internals.shouldBypassSetter ? emptyArray : internals.setters[name] ?? emptyArray;\n        for (let i = 0; i < setters.length; i++) {\n          newValue = setters[i](newValue, oldValue, name);\n          if (newValue === oldValue) {\n            break;\n          }\n        }\n        newValue = internals.accessorSetter[name](newValue, oldValue, name);\n        originalSet.call(this, newValue);\n        if (newValue !== oldValue) {\n          internals.enabledWatchers[name]?.forEach((watcher) => watcher(newValue, oldValue, name));\n        }\n      }\n      if (internals._keyTrackers.length > 0) {\n        internals?._firePropertyTrackers(name, rawNewValue, oldValue);\n      }\n    } : originalSet;\n    if (shouldOverwriteGet) {\n      Object.defineProperty(finalGetter, customAccessor, { value: true });\n    }\n    if (shouldOverwriteSet) {\n      Object.defineProperty(finalSetter, customAccessor, { value: true });\n    }\n    Object.defineProperty(prototype, name, {\n      ...descriptor,\n      get: finalGetter,\n      set: finalSetter\n    });\n  }\n  /**\n   * Associate an exports object with a controller for reverse lookup in\n   * controller.use\n   */\n  markExports(controller, exports) {\n    if (typeof exports === \"object\" && exports !== null || typeof exports === \"function\") {\n      this._exports.set(exports, controller);\n    }\n  }\n  resolveExports(exports) {\n    if (typeof exports === \"object\" && exports !== null || typeof exports === \"function\") {\n      return this._exports.get(exports);\n    } else {\n      return void 0;\n    }\n  }\n};\nvar emptyArray = [];\nvar customAccessor = Symbol(\"controllersCustomAccessor\");\nvar nothing = Symbol(\"nothing\");\nvar useControllerManager = (component, forceUpdate) => new ControllerManager(component, forceUpdate);\nvar ControllerManager = class extends GenericController {\n  constructor(component, forceUpdate) {\n    const isLit = \"addController\" in component;\n    const controllers = /* @__PURE__ */ new Set();\n    function addController(controller) {\n      controllers.add(controller);\n      if (isLit && !(controllerSymbol in controller) && component.el.isConnected) {\n        controller.hostConnected?.();\n      }\n    }\n    function removeController(controller) {\n      void controllers.delete(controller);\n      controller.controllerRemoved?.();\n    }\n    const controllerHost = component;\n    controllerHost.addController = addController;\n    controllerHost.removeController = removeController;\n    if (!isLit) {\n      const update = forceUpdate ?? component.constructor.__forceUpdate;\n      controllerHost.requestUpdate = () => update(component);\n    }\n    super(component);\n    this.internals = new ComponentInternals(this.component);\n    this.destroyed = false;\n    this._updatePromise = new Deferred();\n    this._originalLifecycles = {};\n    /**\n     * A magical solution to finding out what property name a given controller\n     * on a given object was assigned to. Note, this does not work for properties\n     * that have \\@Prop() or \\@State() decorator - for those, use\n     * manager.trackPropKey() instead.\n     *\n     * @example\n     * function trackMe<T>(defaultValue:T, component:BaseComponent):T {\n     *   component.manager.trackPropertyKey(component, (key)=>console.log(key), defaultValue);\n     *   return defaultValue;\n     * }\n     *\n     * class MyComponent extends BaseComponent {\n     *   // Will console log \"myProp\"\n     *   myProp = trackMe('a', this);\n     * }\n     *\n     */\n    this.trackPropertyKey = trackPropertyKey;\n    /**\n     * Like manager.trackPropertyKey(), but for props that have \\@State() or \\@Prop()\n     * decorator\n     *\n     * @example\n     * function trackMe(component:BaseComponent) {\n     *   component.manager.trackPropKey((key)=>console.log(key));\n     * }\n     *\n     * class MyComponent extends BaseComponent {\n     *   // Will console log \"myProp\"\n     *   @Prop() myProp = trackMe(this);\n     *\n     *   // Will console log \"myState\"\n     *   @State() myState = trackMe(this);\n     * }\n     */\n    this.trackPropKey = this.internals.trackPropKey;\n    /**\n     * A combination of trackPropertyKey() and trackPropKey(). For usage when\n     * you want to track a property, but don't know if it will be defined with the\n     * \\@Prop() decorator or not\n     */\n    this.trackKey = this.internals.trackKey;\n    this._readonlySetter = (newValue, oldValue, property) => {\n      if (Controller.internals.shouldBypassReadonly) {\n        return newValue;\n      }\n      const component = this.component;\n      const isProp = getPropType(component, property) === \"prop\";\n      if (isProp) {\n        if (this.isLit) {\n          const details = getLitProperties(component).get(property);\n          if (details && details?.attribute !== false) {\n            component.el.setAttribute(\n              typeof details.attribute === \"string\" ? details.attribute : camelToKebab(property),\n              // Not using converter.toAttribute to keep this unlikely case simpler\n              String(oldValue)\n            );\n          }\n        } else {\n          component.requestUpdate();\n        }\n      }\n      throw new Error(\n        `Cannot assign to read-only property \"${property}\" of ${component.el.tagName.toLowerCase()}. Trying to assign \"${String(\n          newValue\n        )}\"`\n      );\n    };\n    /**\n     * In development, on hot module reload, controller would be re-initialized\n     * with all Props and State values persistent, but properties lost. This unsafe\n     * development-only API lets you set or get data for a controller that would\n     * persist across hot reloads.\n     */\n    this.devOnlySetPersistentControllerData = void 0 ;\n    this.devOnlyGetPersistentControllerData = void 0 ;\n    this.isLit = isLit;\n    this.component.manager = this;\n    retrieveComponentMembers(component, isLit);\n    this._controllers = controllers;\n    this.exports = void 0;\n    this.hasDestroy = \"autoDestroyDisabled\" in this.component && typeof this.component.destroy === \"function\";\n    if (this.hasDestroy) {\n      this.watch(\"autoDestroyDisabled\", () => this._autoDestroyDisabledWatcher());\n    }\n    this._bindLifecycleMethods();\n    if (!isLit) {\n      Object.defineProperty(component, \"updateComplete\", {\n        get: async () => await this._updatePromise.promise\n      });\n    }\n    const members = getPropLikeMembers(component);\n    const internals = component.manager.internals;\n    members.forEach((name) => {\n      internals.accessorGetter[name] = defaultGetterSetter;\n      internals.accessorSetter[name] = defaultGetterSetter;\n      internals.getSetProxy(name, true, true);\n    });\n    Controller.internals.setParentController(void 0);\n    Controller.internals.setAmbientComponent(component);\n    Controller.internals.elementToInstance.set(component.el, component);\n    Controller.internals.elementToInstance.set(component, component);\n  }\n  _bindLifecycleMethods() {\n    const component = this.component;\n    const isLit = this.isLit;\n    const isStencilDistBuild = component.el === component;\n    this._originalLifecycles = {\n      // These component's callbacks will be called by Lit, so we don't have to\n      connectedCallback: isLit || isStencilDistBuild ? void 0 : component.connectedCallback,\n      disconnectedCallback: isLit || isStencilDistBuild ? void 0 : component.disconnectedCallback,\n      componentWillLoad: isLit ? void 0 : component.componentWillLoad,\n      componentDidLoad: isLit ? void 0 : component.componentDidLoad,\n      componentWillUpdate: isLit ? void 0 : component.componentWillUpdate,\n      componentDidUpdate: isLit ? void 0 : component.componentDidUpdate,\n      destroy: component.destroy\n    };\n    const hostConnected = this._connectedCallback.bind(this);\n    const hostDisconnected = this._disconnectedCallback.bind(this);\n    const hostUpdate = this._update.bind(this);\n    const hostUpdated = this._updated.bind(this);\n    if (isLit) {\n      component.constructor.prototype.addController.call(component, {\n        // Lit will call these callbacks\n        hostConnected,\n        hostDisconnected,\n        hostUpdate,\n        hostUpdated\n      });\n    } else {\n      component.connectedCallback = hostConnected;\n      component.disconnectedCallback = hostDisconnected;\n      component.componentWillLoad = this._load.bind(this);\n      component.componentDidLoad = this._loaded.bind(this);\n      component.componentWillUpdate = hostUpdate;\n      component.componentDidUpdate = hostUpdated;\n    }\n    if (this.hasDestroy) {\n      component.destroy = this.destroy.bind(this);\n    }\n  }\n  /**\n   * Throws an error if component does not implement destroy() lifecycle, but\n   * tries to use it.\n   */\n  ensureHasDestroy() {\n    if (!this.hasDestroy) {\n      throw new Error(destroyErrorMessage);\n    }\n  }\n  /**\n   * Private because this is not supposed to be called by Component directly.\n   * Instead, _bindLifecycleMethods will take care of that. Otherwise, you risk\n   * calling lifecycle methods twice.\n   */\n  _connectedCallback() {\n    if (this.destroyed) {\n      const tagName = this.component.el.tagName.toLowerCase();\n      this.component.el.remove();\n      throw new Error(\n        `The ${tagName} component has already been destroyed. It can not be used again. If you meant to disconnect and reconnect a component without automatic destroy, set the autoDestroyDisabled prop.`\n      );\n    }\n    if (this._autoDestroyTimeout !== void 0) {\n      clearTimeout(this._autoDestroyTimeout);\n    }\n    this.internals.enabledWatchers = this.internals.allWatchers;\n    keyTrackResolve();\n    this._controllers.forEach(\n      (controller) => \"triggerConnected\" in controller ? controller.triggerConnected() : safeCall(controller.hostConnected, controller)\n    );\n    this._originalLifecycles.connectedCallback?.call(this.component);\n  }\n  _disconnectedCallback() {\n    if (this.destroyed) {\n      return;\n    }\n    this._controllers.forEach(\n      (controller) => \"triggerDisconnected\" in controller ? controller.triggerDisconnected() : safeCall(controller.hostDisconnected, controller)\n    );\n    this._originalLifecycles.disconnectedCallback?.call(this.component);\n    if (this.hasDestroy) {\n      this._autoDestroyDisabledWatcher();\n    }\n  }\n  async _load() {\n    const integrations = this.internals.reactiveUtilsIntegrations;\n    if (integrations.size > 0) {\n      for (const controller of integrations) {\n        if (\"triggerLoad\" in controller) {\n          await controller.triggerLoad();\n        } else {\n          await safeAsyncCall(controller.hostLoad, controller);\n        }\n      }\n    }\n    await Promise.allSettled(\n      Array.from(\n        this._controllers,\n        async (controller) => integrations.has(controller) ? void 0 : \"triggerLoad\" in controller ? await controller.triggerLoad() : await safeAsyncCall(controller.hostLoad, controller)\n      )\n    );\n    await this._originalLifecycles.componentWillLoad?.call(this.component);\n  }\n  _loaded() {\n    this._controllers.forEach(\n      (controller) => \"triggerLoaded\" in controller ? controller.triggerLoaded() : safeCall(controller.hostLoaded, controller)\n    );\n    this._originalLifecycles.componentDidLoad?.call(this.component);\n  }\n  _update() {\n    this._controllers.forEach(\n      (controller) => \"triggerUpdate\" in controller ? controller.triggerUpdate() : safeCall(controller.hostUpdate, controller)\n    );\n    void this._originalLifecycles.componentWillUpdate?.call(this.component);\n  }\n  _updated() {\n    this._controllers.forEach(\n      (controller) => \"triggerUpdated\" in controller ? controller.triggerUpdated() : safeCall(controller.hostUpdated, controller)\n    );\n    this._originalLifecycles.componentDidUpdate?.call(this.component);\n    if (!this.isLit) {\n      const updatePromise = this._updatePromise;\n      this._updatePromise = new Deferred();\n      updatePromise.resolve(true);\n    }\n  }\n  async destroy() {\n    this.ensureHasDestroy();\n    if (this.destroyed) {\n      return;\n    }\n    if (this.component.el.isConnected) {\n      this.hasDestroy = false;\n      try {\n        this.component.el.remove();\n      } finally {\n        this.hasDestroy = true;\n      }\n    }\n    this._autoDestroyTimeout = void 0;\n    this.destroyed = true;\n    this._controllers.forEach(\n      (controller) => \"triggerDestroy\" in controller ? controller.triggerDestroy() : safeCall(controller.hostDestroy, controller)\n    );\n    this._controllers.clear();\n    await this._originalLifecycles.destroy?.call(this.component);\n  }\n  _autoDestroyDisabledWatcher() {\n    if (!this.component.el.isConnected && !this.component.autoDestroyDisabled) {\n      if (this._autoDestroyTimeout !== void 0) {\n        clearTimeout(this._autoDestroyTimeout);\n      }\n      const destroy = () => void this.destroy().catch(console.error);\n      {\n        this._autoDestroyTimeout = devToolsAwareTimeout(destroy, autoDestroyOnDisconnectTimeout);\n      }\n    }\n  }\n  // REFACTOR: replace this with a readonly:true option in @property()\n  /**\n   * Make a @Prop() or @State() readonly (prevent overwriting default value).\n   *\n   * For internal properties, prefer TypeScript's \"readonly\" modifier instead.\n   *\n   * @example\n   * // Defining readonly prop\n   * @Prop({ reflect: true }) prop = this.manager.readonly('a');\n   *\n   * @example\n   * // Overwriting readonly prop internally\n   * this.manager.bypassReadonly(()=>{\n   *   this.prop = 'b';\n   * });\n   *\n   */\n  readonly(value) {\n    return this.getSet(value, { set: this._readonlySetter });\n  }\n  // REFACTOR: remove this in Lit in favor of native get/set\n  /**\n   * Listen for any component's @State()/@Prop() change, and mutate it's\n   * value before it is set.\n   * This is necessary because Stencil's Compiler does not support get/set for\n   * @State()/@Prop().\n   * For private component properties, you should use regular get/set syntax.\n   *\n   * @example\n   * @Prop() exampleProp = this.manager.getSet(defaultValue,{get,set})\n   * @Prop() someProp = this.manager.getSet(\n   *   undefined as string | undefined,\n   *   {\n   *     get: (value)=>value.trim(),\n   *     set: (newValue,oldValue) => newValue.trim() ?? oldValue\n   *   }\n   * )\n   *\n   * @remarks\n   * Unlike a native get/set, the get function receives the current attribute\n   * value, and can modify it before returning it (or can disregard the current\n   * value and get it from elsewhere instead).\n   * Similarly, setter is called with the new and old value, and is expected to\n   * return the final new value (or return the old value to undo the change)\n   */\n  getSet(defaultValue, getSet) {\n    return this.component.manager.trackPropKey((name) => {\n      var _a2;\n      if (name === void 0) {\n        throw new Error(\n          \"Unable to resolve get/set's prop name. Make sure you are using it like @Prop() someProp = this.manager.getSet(defaultValue,{get,set})\"\n        );\n      }\n      if (getSet.set === this._readonlySetter) {\n        (_a2 = this.internals).readonlyProps ?? (_a2.readonlyProps = /* @__PURE__ */ new Set());\n        this.internals.readonlyProps.add(name);\n      }\n      const genericComponent = this.component;\n      const value = genericComponent[name];\n      const isStencilHotReload = \"production\" !== \"production\"  ;\n      const initialSet = getSet.initialSet ?? true;\n      if (value != null && value !== defaultValue && typeof getSet.set === \"function\" && initialSet && !isStencilHotReload) {\n        const newValue = getSet.set(value, defaultValue, name);\n        if (newValue !== value) {\n          if (this.isLit) {\n            genericComponent[name] = newValue;\n          } else {\n            let firstConnected = true;\n            this.onConnected(() => {\n              if (!firstConnected) {\n                return;\n              }\n              firstConnected = true;\n              this.bypassSetter(() => {\n                genericComponent[name] = newValue;\n              });\n            });\n          }\n        }\n      }\n      this.genericGetSet(name, getSet);\n    }, defaultValue);\n  }\n};\nvar destroyErrorMessage = `\nIf the component uses a controller that uses destroy() method, then the\ncomponent must have the following properties:\n${// Don't expose internal code in production, and keep bundle smaller:\n`autoDestroyDisabled and destroy` }\n`.trim();\nvar autoDestroyOnDisconnectTimeout = 1e3;\nvar defaultGetterSetter = (value) => value;\n\n// src/proxyExports.ts\nvar proxyExports = (Class) => (...args) => {\n  const ambientControllers = Controller.internals.retrieveParentControllers();\n  const instance = new Class(...args);\n  const initialExports = instance.exports;\n  Controller.internals.setParentController(ambientControllers.at(-1));\n  const internals = instance.component.manager.internals;\n  internals.markExports(instance, initialExports);\n  instance.watchExports((exports) => internals.markExports(instance, exports));\n  Controller.internals.setAmbientChildController(instance);\n  const hostCandidates = [instance.component, ...ambientControllers].reverse();\n  return internals.trackKey(\n    hostCandidates,\n    (resolution) => resolution === void 0 ? void 0 : setProxy(instance, resolution, initialExports),\n    initialExports\n  );\n};\nfunction setProxy(controller, { host, key, type }, initialExports) {\n  const genericHost = host;\n  const controllerValueChanged = genericHost[key] !== controller.exports;\n  const hostValueChanged = genericHost[key] !== initialExports;\n  const controllerUpdatedExports = initialExports !== controller.exports;\n  if (controllerValueChanged && !hostValueChanged && controllerUpdatedExports) {\n    genericHost[key] = controller.exports;\n  }\n  const isProxyExportsOnComponent = host === controller.component;\n  if (isProxyExportsOnComponent && type === \"prop\") {\n    const internals = controller.component.manager.internals;\n    if (hostValueChanged) {\n      internals.markExports(controller, genericHost[key]);\n    }\n    controller.component.manager.watch(key, (value) => {\n      if (value !== controller.exports) {\n        internals.markExports(controller, value);\n      }\n    });\n  }\n  controller.watchExports(() => {\n    if (genericHost[key] === controller.exports) {\n      return;\n    }\n    const manager = controller.component.manager;\n    const isReadOnly = manager.internals.readonlyProps?.has(key) === true;\n    if (isReadOnly) {\n      manager.bypassReadonly(() => {\n        genericHost[key] = controller.exports;\n      });\n    } else {\n      genericHost[key] = controller.exports;\n    }\n  });\n}\n\n// src/functional.ts\nvar makeController = (constructor) => proxy$1(void 0, constructor);\nvar FunctionalController = class extends Controller {\n  constructor(component, constructor) {\n    super(component);\n    const originalExports = this.exports;\n    try {\n      Controller.internals.setAmbientComponent(this.component);\n      const value = constructor(this.component, this);\n      const constructorChangedExports = this.exports !== originalExports;\n      if (value instanceof Promise) {\n        if (!constructorChangedExports) {\n          this.setProvisionalExports(value);\n        }\n        const resolved = value.then((result) => {\n          this.exports = result;\n          super.catchUpLifecycle();\n        }).catch((error) => {\n          this._ready.reject(error);\n          console.error(error);\n        });\n        this.onLoad(async () => await resolved);\n      } else {\n        if (!constructorChangedExports || value !== void 0) {\n          this.exports = value;\n        }\n        queueMicrotask(() => super.catchUpLifecycle());\n      }\n    } catch (error) {\n      this._ready.reject(error);\n      console.error(error);\n    }\n  }\n  /** Noop - will be called in the constructor instead */\n  catchUpLifecycle() {\n    return;\n  }\n};\nvar proxy$1 = proxyExports(FunctionalController);\n\nvar makeAccessorController = (loadAccessor, _options) => (component, options) => proxy(component, loadAccessor, options);\nvar AccessorController = class extends GenericController {\n  constructor(component, _loadAccessor, _options) {\n    super(component);\n    this._loadAccessor = _loadAccessor;\n    this._options = _options;\n    this.reactiveUtils = this.component.reactiveUtils;\n    // A mapping from bound component's \"prop\" name to Accessor instance's \"property\"\n    this._watchedProperties = /* @__PURE__ */ new Map();\n    this._isBinding = { value: true };\n    this.setProvisionalExports(\n      accessorSupport.makeGetterProxy(\n        component,\n        this._watchedProperties,\n        this._isBinding,\n        this.constructor.allowedPropNameMismatches\n      )\n    );\n    const integrations = component.manager.internals.reactiveUtilsIntegrations;\n    integrations.add(this);\n    const reactiveUtilsIntegration = Array.from(integrations).find(\n      (integration) => integration instanceof ReactiveUtilsIntegration\n    );\n    if (reactiveUtilsIntegration) {\n      integrations.delete(reactiveUtilsIntegration);\n    }\n    integrations.add(reactiveUtilsIntegration ?? new ReactiveUtilsIntegration(this.component));\n    component.manager.trackPropKey((resolved) => {\n      if (resolved) {\n        this._instancePropName = resolved;\n      }\n    }, this.exports);\n  }\n  hostConnected() {\n    this._isBinding.value = false;\n  }\n  async hostLoad() {\n    const component = this.component;\n    if (component.reactiveUtils === void 0) {\n      this.reactiveUtils = await importCoreReactiveUtils();\n    } else {\n      this.reactiveUtils = await this.use(component.reactiveUtils);\n    }\n    const parameters = accessorSupport.gatherParameters(this, this._watchedProperties);\n    const finalParameters = this._options?.editConstructorProperties?.call(component, parameters) ?? parameters;\n    const awaitedParameters = finalParameters instanceof Promise ? await finalParameters : finalParameters;\n    const genericComponent = component;\n    const existingInstance = typeof this._instancePropName === \"string\" ? genericComponent[this._instancePropName] : void 0;\n    const hasInstance = existingInstance != null && existingInstance !== this.exports;\n    if (hasInstance) {\n      this._instance = existingInstance;\n      existingInstance.set(awaitedParameters);\n    } else {\n      this._instance = await this._createInstance(awaitedParameters);\n    }\n    if (component.manager.destroyed) {\n      return;\n    }\n    accessorSupport.watchComponentUpdates(this, this._instance, this._watchedProperties);\n    accessorSupport.watchAccessorUpdates(this, this._instance, this._watchedProperties);\n    this.exports = this._instance;\n  }\n  async _createInstance(parameters) {\n    if (this._isAccessorConstructor(this._loadAccessor)) {\n      return new this._loadAccessor(parameters);\n    } else {\n      return await this._loadAccessor(parameters);\n    }\n  }\n  _isAccessorConstructor(loader) {\n    return \"prototype\" in loader && \"declaredClass\" in loader.prototype;\n  }\n  hostDestroy() {\n    if (this._instance) {\n      this._instance.destroy();\n    }\n  }\n  async reCreate() {\n    this.hostDestroy();\n    await this.hostLoad();\n  }\n};\nvar proxy = proxyExports(AccessorController);\nvar accessorSupport = {\n  makeGetterProxy: (component, watchedProperties, isBinding, allowedPropNameMismatches) => new Proxy(\n    {},\n    {\n      /*\n       * Without this, makeProvisionalValue() will throw on accessing\n       * non-existent prop\n       */\n      has: (target, prop) => typeof prop === \"string\" || prop in target,\n      get: (target, prop) => {\n        const value = Reflect.get(target, prop);\n        if (typeof prop === \"symbol\" || prop in Promise.prototype) {\n          return value;\n        }\n        const hasProp = prop in target;\n        const doBinding = isBinding?.value ?? true;\n        if (hasProp || !doBinding) {\n          return value;\n        }\n        return component.manager.trackKey(\n          component,\n          (resolved) => {\n            if (resolved !== void 0) {\n              watchedProperties.set(resolved.key, prop);\n            }\n          },\n          value\n        );\n      }\n    }\n  ),\n  // Update Accessor on component prop change\n  watchComponentUpdates(controller, instance, watchedProperties) {\n    function getter(_value, propName) {\n      const propertyName = watchedProperties.get(propName);\n      const value = instance[propertyName];\n      const flipBoolean = typeof value === \"boolean\" && propertyName !== propName && propName.toLowerCase().includes(\"disable\");\n      return flipBoolean ? !value : value;\n    }\n    const setter = (newValue, _oldValue, propName) => {\n      const propertyName = watchedProperties.get(propName);\n      const value = instance[propertyName];\n      const flipBoolean = typeof value === \"boolean\" && propertyName !== propName && propName.toLowerCase().includes(\"disable\");\n      const currentValue = flipBoolean ? !value : value;\n      if (currentValue === newValue) {\n        return newValue;\n      }\n      instance[propertyName] = flipBoolean ? !newValue : newValue;\n      const finalValue = instance[propertyName];\n      return flipBoolean ? !finalValue : finalValue;\n    };\n    const component = controller.component;\n    const internals = component.manager.internals;\n    watchedProperties.forEach((_propName, propertyName) => {\n      internals.accessorGetter[propertyName] = getter;\n      internals.accessorSetter[propertyName] = setter;\n    });\n  },\n  // Update component on Accessor prop change\n  watchAccessorUpdates(controller, instance, watchedProperties) {\n    const { component } = controller;\n    const genericComponent = component;\n    const genericInstance = instance;\n    const readonlyProps = findReadOnlyAccessorProps(instance);\n    component.manager.bypassGetter(\n      () => (\n        // Careful: Map's forEach callback arguments are (value, key), not (key, value)\n        watchedProperties.forEach((propertyName, propName) => {\n          if (readonlyProps.has(propertyName)) {\n            return;\n          }\n          const domValue = genericComponent[propName];\n          const modelValue = genericInstance[propertyName];\n          const flipBoolean = typeof domValue === \"boolean\" && propertyName !== propName && propName.toLowerCase().includes(\"disable\");\n          const resolvedDomValue = flipBoolean ? !domValue : domValue;\n          if (resolvedDomValue != null && modelValue !== resolvedDomValue) {\n            genericInstance[propertyName] = resolvedDomValue;\n          }\n        })\n      )\n    );\n    controller.onLifecycle(() => {\n      if (instance.destroyed) {\n        return;\n      }\n      return Array.from(\n        watchedProperties,\n        ([propName, propertyName]) => controller.reactiveUtils.watch(\n          () => genericInstance[propertyName],\n          () => {\n            const newValue = genericInstance[propertyName];\n            const flipBoolean = typeof newValue === \"boolean\" && propertyName !== propName && propName.toLowerCase().includes(\"disable\");\n            const resolvedNewValue = flipBoolean ? !newValue : newValue;\n            component.manager.bypassSetter(() => {\n              genericComponent[propName] = resolvedNewValue;\n            });\n          },\n          { initial: true }\n        )\n      );\n    });\n  },\n  gatherParameters(controller, watchedProperties) {\n    const { component } = controller;\n    const data = Object.fromEntries(\n      Array.from(watchedProperties, ([prop, property]) => [property, component[prop]]).filter(\n        ([, value]) => value !== void 0\n      )\n    );\n    return data ;\n  },\n  reEmitAccessorEvents(controller, instance, reactiveUtils, prefix) {\n    const isEvented = \"on\" in instance && typeof instance.on === \"function\";\n    if (!isEvented) {\n      return;\n    }\n    const toListen = Object.entries(controller.component).map(([key, unknown]) => {\n      const value = unknown;\n      if (!key.startsWith(prefix) || key === prefix || typeof value !== \"object\" || value === null || !(\"emit\" in value) || typeof value.emit !== \"function\") {\n        return void 0;\n      }\n      const emit = value.emit;\n      const trimmedEventName = key.slice(prefix.length);\n      const camelCaseEventName = camelToKebab(trimmedEventName);\n      const eventName = camelCaseEventName.toLowerCase();\n      return [eventName, emit];\n    }).filter(isNotUndefined);\n    if (toListen.length === 0) {\n      return;\n    }\n    const eventTarget = instance;\n    const getEventTarget = () => eventTarget;\n    controller.onLifecycle(() => {\n      if (instance.destroyed) {\n        return;\n      }\n      return toListen.map(([eventName, emit]) => reactiveUtils.on(getEventTarget, eventName, emit));\n    });\n  },\n  async reCreate(instance, component) {\n    const accessorController = component.manager.useRefSync(instance);\n    if (accessorController === void 0) {\n      return;\n    }\n    await accessorController.reCreate();\n  }\n};\nfunction findReadOnlyAccessorProps(instance) {\n  const accessor = instance;\n  const properties = Object.entries(accessor.__accessor__?.metadata ?? {});\n  return new Set(\n    properties.filter(([_property, descriptor]) => descriptor?.readOnly === true).map(([property]) => property)\n  );\n}\nvar accessorPromise = Promise.all([importCoreAccessor(), importCoreAccessorSupportDecorators()]);\nvar ReactiveUtilsIntegration = class extends GenericController {\n  async hostLoad() {\n    const [Accessor, { subclass, property }] = await accessorPromise;\n    class AccessorSubclass extends Accessor {\n    }\n    const getter = (_value, propertyName) => accessor[propertyName];\n    function setter(newValue, _oldValue, propertyName) {\n      if (accessor !== void 0) {\n        accessor[propertyName] = newValue;\n      }\n      return newValue;\n    }\n    const component = this.component;\n    const internals = component.manager.internals;\n    const enabledMembers = [];\n    const allMembers = getPropLikeMembers(this.component);\n    component.manager.bypassGetter(\n      () => allMembers.forEach((name) => {\n        const alreadyIntegrated = internals.accessorSetter[name] !== defaultGetterSetter;\n        if (alreadyIntegrated) {\n          return;\n        }\n        enabledMembers.push(name);\n        internals.accessorGetter[name] = getter;\n        internals.accessorSetter[name] = setter;\n        property({\n          value: component[name]\n        })(AccessorSubclass.prototype, name);\n      })\n    );\n    this._enabledMembers = enabledMembers;\n    if (enabledMembers.length === 0) {\n      return;\n    }\n    const Subclass = subclass(component.el.tagName)(AccessorSubclass);\n    const accessor = new Subclass();\n    this._instance = accessor;\n  }\n  controllerRemoved() {\n    super.controllerRemoved();\n    const internals = this.component.manager.internals;\n    this._instance?.destroy();\n    this._enabledMembers?.forEach((name) => {\n      internals.accessorGetter[name] = defaultGetterSetter;\n      internals.accessorSetter[name] = defaultGetterSetter;\n    });\n  }\n};\n\nexport { AccessorController as A, accessorSupport as a, makeController as b, makeAccessorController as m, proxyExports as p, useControllerManager as u };\n"],"names":["getLitProperties","component","constructor","elementProperties","filter","getPropLikeMembers","members","manager","internals","Object","entries","_ref2","_name","propType","map","_ref3","name","getMemberType","_component$manager$in","getPropType","type","_a","controllerSymbol","Symbol","unresolvableExports","join","_Controller","this","_callbacks","hostConnected","hostDisconnected","hostLoad","hostLoaded","hostUpdate","hostUpdated","hostDestroy","hostLifecycle","_ready","Deferred","_lifecycleDisconnected","connectedCalled","willLoadCalled","didLoadCalled","ready","promise","_exports","makeProvisionalValue","_exportWatchers","Set","resolvedComponent","Error","toControllerHost","retrieveComponent","defineProperty","writable","enumerable","configurable","value","addController","setParentController","ensureHasDestroy","queueMicrotask","catchUpLifecycle","triggerConnected","triggerLoad","then","triggerLoaded","catch","console","error","exports","requestUpdate","forEach","safeCall","resolve","setProvisionalExports","watchExports","callback","safeCallback","add","delete","use","setAmbientComponent","useRef","useRefSync","bypassSetter","shouldBypassSetter","bypassReadonly","shouldBypassReadonly","bypassGetter","shouldBypassGetter","dynamicGetSet","getSet","genericGetSet","property","_a2","_b","_a2$property","get","getters","unshift","set","ignoreSet","_b$property","setters","watch","_a2$property2","concat","allWatchers","watchers","genericCallback","newValue","oldValue","propertyName","push","index","indexOf","splice","controllerRemoved","el","isConnected","triggerDisconnected","triggerDestroy","onConnected","onDisconnected","onLoad","onLoaded","onUpdate","onUpdated","onDestroy","onLifecycle","_callLifecycle","genericController","triggerLifecycle","safeAsyncCall","length","Promise","allSettled","triggerUpdate","triggerUpdated","cleanupRaw","Array","isArray","cleanup2","remove","_ambientControllers","async","controller","unsubscribe","ambientChildController","retrieveAmbientChildController","Controller","resolveExports","isController","elementToInstance","WeakMap","_ambientComponent","slice","retrieveParentControllers","setAmbientChildController","_ambientChildController","GenericController","super","base","proxy2","Proxy","target","prop","receiver","cyclical","has","prototype","Reflect","toString","accessBeforeLoad","_","trackPropertyKey","object","onResolved","defaultValue","_keyTrackMap","keys","keyCount","keyTrackMap","keyTrackResolve","Map","pendingTrackers","callbacks","keys2","key2","key","_keyTrackMap$entries","_keyTrackMap2","from","_ref4","commit","ComponentInternals","enabledWatchers","trackKey","hostsCandidates","candidateHosts","leftToResolve","resolved","resolution","host","domValue","trackPropKey","_trackedValue","nothing","_firePropertyTrackers","_keyTrackers","previousValue","accessorGetter","accessorSetter","reactiveUtilsIntegrations","trackers","tracker","getSetProxy","hasGetter","hasSetter","classPrototype","_getSetProxy","isLit","htmlPrototype","descriptor","getOwnPropertyDescriptor","tolerateNotFound","tagName","originalGet","originalSet","shouldOverwriteGet","customAccessor","shouldOverwriteSet","finalGetter","_internals$getters$na","call","component2","emptyArray","i","finalSetter","rawNewValue","arguments","undefined","Number","parseFloat","String","parsePropertyValue","_internals$setters$na","_internals$enabledWat","watcher","markExports","useControllerManager","forceUpdate","ControllerManager","controllers","controllerHost","_controller$hostConne","removeController","_controller$controlle","update","__forceUpdate","destroyed","_updatePromise","_originalLifecycles","_readonlySetter","details","attribute","setAttribute","camelToKebab","toLowerCase","devOnlySetPersistentControllerData","devOnlyGetPersistentControllerData","fromEntries","_ref","state","Boolean","_constructor$__regist","_constructor$__regist2","__registerControllers","retrieveComponentMembers","_controllers","hasDestroy","destroy","_autoDestroyDisabledWatcher","_bindLifecycleMethods","defaultGetterSetter","isStencilDistBuild","connectedCallback","disconnectedCallback","componentWillLoad","componentDidLoad","componentWillUpdate","componentDidUpdate","_connectedCallback","bind","_disconnectedCallback","_update","_updated","_load","_loaded","destroyErrorMessage","_this$_originalLifecy","_autoDestroyTimeout","clearTimeout","_this$_originalLifecy2","_this$_originalLifecy3","integrations","size","_this$_originalLifecy4","_this$_originalLifecy5","_this$_originalLifecy6","updatePromise","_this$_originalLifecy7","clear","autoDestroyDisabled","devToolsAwareTimeout","autoDestroyOnDisconnectTimeout","readonly","_getSet$initialSet","_a2$readonlyProps","readonlyProps","genericComponent","initialSet","firstConnected","trim","proxyExports","Class","ambientControllers","_len","args","_key","instance","initialExports","at","hostCandidates","reverse","_ref5","genericHost","controllerValueChanged","hostValueChanged","controllerUpdatedExports","_manager$internals$re","setProxy","makeController","proxy$1","originalExports","constructorChangedExports","result","reject","makeAccessorController","loadAccessor","_options","options","proxy","AccessorController","_loadAccessor","reactiveUtils","_watchedProperties","_isBinding","accessorSupport","makeGetterProxy","allowedPropNameMismatches","reactiveUtilsIntegration","find","integration","ReactiveUtilsIntegration","_instancePropName","_this$_options$editCo","_this$_options","importCoreReactiveUtils","parameters","gatherParameters","finalParameters","editConstructorProperties","awaitedParameters","existingInstance","_instance","_createInstance","watchComponentUpdates","watchAccessorUpdates","_isAccessorConstructor","loader","reCreate","watchedProperties","isBinding","_isBinding$value","hasProp","doBinding","getter","_value","propName","includes","setter","_oldValue","flipBoolean","finalValue","_propName","genericInstance","_accessor$__accessor_","_accessor$__accessor_2","accessor","properties","__accessor__","metadata","_ref11","_property","readOnly","_ref12","findReadOnlyAccessorProps","modelValue","resolvedDomValue","_ref6","resolvedNewValue","initial","_ref7","_ref8","reEmitAccessorEvents","prefix","on","toListen","_ref9","unknown","startsWith","emit","trimmedEventName","isNotUndefined","eventTarget","getEventTarget","_ref10","eventName","accessorController","accessorPromise","all","importCoreAccessor","importCoreAccessorSupportDecorators","Accessor","subclass","AccessorSubclass","enabledMembers","allMembers","_enabledMembers","_this$_instance","_this$_enabledMembers"],"sourceRoot":""}